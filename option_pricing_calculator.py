# -*- coding: utf-8 -*-
"""Option Pricing Calculator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s4TvBLZ7fSN5-oytRZ4N9O0oZejBhUBR
"""

"""
Simple Options Pricing Calculator with User Input
Just run and enter your values!
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

def black_scholes(S, K, T, r, sigma, option_type='call'):
    """Calculate Black-Scholes option price"""
    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
    d2 = d1 - sigma*np.sqrt(T)

    if option_type == 'call':
        return S*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)
    else:
        return K*np.exp(-r*T)*norm.cdf(-d2) - S*norm.cdf(-d1)

def calculate_greeks(S, K, T, r, sigma, option_type='call'):
    """Calculate option Greeks"""
    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
    d2 = d1 - sigma*np.sqrt(T)

    delta = norm.cdf(d1) if option_type == 'call' else norm.cdf(d1) - 1
    gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))
    vega = S * norm.pdf(d1) * np.sqrt(T) / 100

    if option_type == 'call':
        theta = (-S*norm.pdf(d1)*sigma/(2*np.sqrt(T)) - r*K*np.exp(-r*T)*norm.cdf(d2)) / 365
    else:
        theta = (-S*norm.pdf(d1)*sigma/(2*np.sqrt(T)) + r*K*np.exp(-r*T)*norm.cdf(-d2)) / 365

    rho = K*T*np.exp(-r*T)*norm.cdf(d2)/100 if option_type=='call' else -K*T*np.exp(-r*T)*norm.cdf(-d2)/100

    return {'Delta': delta, 'Gamma': gamma, 'Vega': vega, 'Theta': theta, 'Rho': rho}

def monte_carlo(S, K, T, r, sigma, option_type='call', sims=50000):
    """Monte Carlo option pricing"""
    np.random.seed(42)
    Z = np.random.standard_normal(sims)
    ST = S * np.exp((r - 0.5*sigma**2)*T + sigma*np.sqrt(T)*Z)

    if option_type == 'call':
        payoffs = np.maximum(ST - K, 0)
    else:
        payoffs = np.maximum(K - ST, 0)

    return np.exp(-r*T) * np.mean(payoffs)

def plot_results(S, K, T, r, sigma, option_type):
    """Plot payoff diagram and Greeks"""
    spots = np.linspace(S*0.7, S*1.3, 100)
    prices = [black_scholes(s, K, T, r, sigma, option_type) for s in spots]
    intrinsic = [max(s-K, 0) if option_type=='call' else max(K-s, 0) for s in spots]

    bs_price = black_scholes(S, K, T, r, sigma, option_type)
    greeks = calculate_greeks(S, K, T, r, sigma, option_type)

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Payoff diagram
    ax1.plot(spots, prices, 'g-', linewidth=3, label='Option Value')
    ax1.plot(spots, intrinsic, 'r--', linewidth=2, label='Intrinsic Value')
    ax1.axvline(K, color='orange', linestyle=':', linewidth=2, label='Strike', alpha=0.7)
    ax1.axvline(S, color='cyan', linestyle=':', linewidth=2, label='Current Spot', alpha=0.7)
    ax1.set_xlabel('Spot Price ($)', fontsize=12)
    ax1.set_ylabel('Option Value ($)', fontsize=12)
    ax1.set_title(f'{option_type.upper()} Option Payoff (Price: ${bs_price:.2f})', fontsize=13, fontweight='bold')
    ax1.legend(loc='best', fontsize=10)
    ax1.grid(True, alpha=0.3)

    # Greeks bar chart
    greek_names = ['Delta', 'Gamma\n(x100)', 'Vega', 'Theta', 'Rho']
    greek_values = [
        greeks['Delta'],
        greeks['Gamma']*100,
        greeks['Vega'],
        greeks['Theta'],
        greeks['Rho']
    ]
    colors = ['#27ae60', '#f39c12', '#3498db', '#e74c3c', '#9b59b6']

    bars = ax2.bar(greek_names, greek_values, color=colors, alpha=0.8, edgecolor='black', linewidth=1.5)
    ax2.axhline(0, color='black', linewidth=1, linestyle='-')
    ax2.set_ylabel('Greek Value', fontsize=12)
    ax2.set_title('Option Greeks', fontsize=13, fontweight='bold')
    ax2.grid(True, alpha=0.3, axis='y')

    # Add value labels on bars
    for bar, value in zip(bars, greek_values):
        height = bar.get_height()
        ax2.text(bar.get_x() + bar.get_width()/2., height,
                f'{value:.3f}',
                ha='center', va='bottom' if height > 0 else 'top',
                fontsize=10, fontweight='bold')

    plt.tight_layout()
    plt.show()

def main():
    """Main function to run the calculator"""
    print("="*70)
    print("         OPTIONS PRICING CALCULATOR")
    print("         Black-Scholes + Monte Carlo + Greeks")
    print("="*70)

    # Get user inputs
    print("\nEnter the following parameters:")
    print("-" * 70)

    try:
        option_type = input("Option Type (call/put) [default: call]: ").strip().lower() or 'call'
        if option_type not in ['call', 'put']:
            print("Invalid option type. Using 'call'")
            option_type = 'call'

        S = float(input("Current Spot Price ($) [default: 100]: ") or 100)
        K = float(input("Strike Price ($) [default: 100]: ") or 100)
        T = float(input("Time to Expiry (years) [default: 1]: ") or 1)
        r = float(input("Risk-Free Rate (as decimal, e.g., 0.05 for 5%) [default: 0.05]: ") or 0.05)
        sigma = float(input("Volatility (as decimal, e.g., 0.20 for 20%) [default: 0.20]: ") or 0.20)

        print("\n" + "="*70)
        print("CALCULATING...")
        print("="*70)

        # Calculate prices
        bs_price = black_scholes(S, K, T, r, sigma, option_type)
        mc_price = monte_carlo(S, K, T, r, sigma, option_type)
        greeks = calculate_greeks(S, K, T, r, sigma, option_type)

        # Determine moneyness
        if option_type == 'call':
            moneyness = 'ITM (In The Money)' if S > K else 'OTM (Out of The Money)' if S < K else 'ATM (At The Money)'
        else:
            moneyness = 'ITM (In The Money)' if S < K else 'OTM (Out of The Money)' if S > K else 'ATM (At The Money)'

        # Display results
        print("\n" + "="*70)
        print("INPUT SUMMARY")
        print("="*70)
        print(f"Option Type:         {option_type.upper()}")
        print(f"Spot Price (S):      ${S:.2f}")
        print(f"Strike Price (K):    ${K:.2f}")
        print(f"Time to Expiry (T):  {T:.2f} years ({int(T*365)} days)")
        print(f"Risk-Free Rate (r):  {r*100:.2f}%")
        print(f"Volatility (σ):      {sigma*100:.2f}%")
        print(f"Moneyness:           {moneyness}")

        print("\n" + "="*70)
        print("OPTION PRICING RESULTS")
        print("="*70)
        print(f"Black-Scholes Price: ${bs_price:.4f}")
        print(f"Monte Carlo Price:   ${mc_price:.4f} (50,000 simulations)")
        print(f"Difference:          ${abs(bs_price - mc_price):.4f}")

        print("\n" + "="*70)
        print("OPTION GREEKS")
        print("="*70)
        print(f"Delta (Δ):           {greeks['Delta']:>8.4f}  (Price change per $1 spot move)")
        print(f"Gamma (Γ):           {greeks['Gamma']:>8.4f}  (Delta change per $1 spot move)")
        print(f"Vega (ν):            {greeks['Vega']:>8.4f}  (Price change per 1% vol change)")
        print(f"Theta (Θ):           {greeks['Theta']:>8.4f}  (Time decay per day)")
        print(f"Rho (ρ):             {greeks['Rho']:>8.4f}  (Price change per 1% rate change)")

        print("\n" + "="*70)
        print("INTERPRETATION")
        print("="*70)

        if option_type == 'call':
            print(f"• This call option gives the RIGHT to BUY at ${K:.2f}")
            print(f"• Current profit if exercised now: ${max(S-K, 0):.2f}")
        else:
            print(f"• This put option gives the RIGHT to SELL at ${K:.2f}")
            print(f"• Current profit if exercised now: ${max(K-S, 0):.2f}")

        print(f"• Delta {greeks['Delta']:.3f} means: ${abs(greeks['Delta']):.3f} price change for $1 spot move")
        print(f"• Theta {greeks['Theta']:.3f} means: You lose ${abs(greeks['Theta']):.3f} per day (time decay)")

        print("\n" + "="*70)

        # Ask if user wants to see plots
        show_plot = input("\nShow visualizations? (yes/no) [default: yes]: ").strip().lower()
        if show_plot != 'no':
            plot_results(S, K, T, r, sigma, option_type)

        # Ask if user wants to calculate again
        print("\n" + "="*70)
        again = input("\nCalculate another option? (yes/no): ").strip().lower()
        if again == 'yes' or again == 'y':
            print("\n" * 2)
            main()
        else:
            print("\nThank you for using the Options Pricing Calculator!")
            print("="*70)

    except ValueError as e:
        print(f"\nError: Invalid input. Please enter numerical values.")
        print(f"Details: {e}")
        retry = input("\nTry again? (yes/no): ").strip().lower()
        if retry == 'yes' or retry == 'y':
            print("\n" * 2)
            main()
    except Exception as e:
        print(f"\nAn error occurred: {e}")

# Run the calculator
if __name__ == "__main__":
    main()